<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="http://localhost:4000/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2016-11-30T23:53:54+08:00</updated><id>http://localhost:4000//</id><title type="html">随记</title><subtitle>郜</subtitle><author><name>xubin gao</name></author><entry><title type="html">php内缓存的使用</title><link href="http://localhost:4000/2016/11/28/php-cache/" rel="alternate" type="text/html" title="php内缓存的使用" /><published>2016-11-28T00:00:00+08:00</published><updated>2016-11-28T00:00:00+08:00</updated><id>http://localhost:4000/2016/11/28/php-cache</id><content type="html" xml:base="http://localhost:4000/2016/11/28/php-cache/">&lt;p&gt;为了使程序执行速度更快，所以现有业务中大量使用了缓存机制，这里主要介绍下平时业务中用到的缓存的应用及缓存更新的策略。由于缓存涉及到的场景太多了，所以本次仅介绍书写代码时最最常用的基础知识。&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;缓存的应用&lt;/h1&gt;

&lt;p&gt;一般模式&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/php_cache/cache-demo.png&quot; alt=&quot;cache-demo&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;php&quot;&gt;php中变量级别的缓存&lt;/h2&gt;

&lt;p&gt;适用场景：对于数据量较少，获取耗时，读多写少的情况&lt;/p&gt;

&lt;p&gt;缺点：仅在生命周期内生效，进程间无法共享&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
class A {
    public static $x = null;
    public static $xx = null;

    public function getX() {
        if(!is_null(self::$x)) {
            return self::$x;
        }

        //todo 耗时处理 START
        $x = 'xxxx';
        //todo 耗时处理 END

        return self::$x = $x;
    }

    public function getXx($key) {
        if(isset(self::$xx[$key])) {
            return self::$xx[$key];
        }

        self::$xx = array();

        //todo 耗时处理 START
        $x = 'xxxx';
        //todo 耗时处理 END

        return self::$xx[$key] = $x;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里可以思考下 geX 和 getXx 的应用场景&lt;/p&gt;

&lt;h2 id=&quot;redis-&quot;&gt;Redis 缓存&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;优点：高并发集群读写&lt;/li&gt;
  &lt;li&gt;常用数据结构： key/string/hash/set/list/sortedset&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;功能及应用场景&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;key 键
    &lt;ul&gt;
      &lt;li&gt;keys 线上服务杜绝使用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;string 字符串
    &lt;ul&gt;
      &lt;li&gt;incr 原子性的计数器。对于并发的计数如PV/点击等可以使用 incr 存储，然后再入库&lt;/li&gt;
      &lt;li&gt;setex set 某个值同时设置过期时间&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;hash   哈希表
    &lt;ul&gt;
      &lt;li&gt;存储结构化的数据&lt;/li&gt;
      &lt;li&gt;避免将数据 json_encode 之后按照 key - value 方式存储，更加节省空间&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;set    集合
    &lt;ul&gt;
      &lt;li&gt;set元素最大可以包含(2的32次方-1)个元素，可以做 并集、交集、差集 的处理，比如 共同好友&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;list   列表
    &lt;ul&gt;
      &lt;li&gt;一般作为队列使用。注意队列消费者使用阻塞模式的blpop&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;sortedset  有序集合
    &lt;ul&gt;
      &lt;li&gt;一般存储有权重的数据，比如 排行榜&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section-2&quot;&gt;缓存常见问题&lt;/h1&gt;

&lt;h2 id=&quot;section-3&quot;&gt;穿透&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;现象&lt;/p&gt;

    &lt;p&gt;其实就是查询一个不存在的数据，缓存中没有，然后又去数据库读，数据库中获取不到则不会更新缓存。这就导致每次的请求都会去存储层查询，失去了缓存的意义。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如何避免&lt;/p&gt;

    &lt;p&gt;如果有大量请求都穿透的话，数据库压力会非常大。所以在特定情境中需要对穿透的数据设置缓存，比如缓存一个标识，告诉请求没有数据，避免穿透。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;雪崩&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;现象&lt;/p&gt;

    &lt;p&gt;缓存服务器重启或缓存集中在同一段短时间内失效，导致大量的强求都打到数据库或后端服务，造成服务压力过大。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如何解决&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;缓存服务器 高可用&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;key的过期时间尽量分散&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;redis--1&quot;&gt;Redis 缓存过期&lt;/h2&gt;

&lt;h3 id=&quot;section-5&quot;&gt;如何删除过期建？&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;当一个键被访问时，程序会对这个键进行检查，如果键已经过期，那么该键将被删除&lt;/li&gt;
  &lt;li&gt;底层系统会在后台渐进地查找并删除那些过期的键，从而处理那些已经过期、但是不会被访问到的键&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;redis--2&quot;&gt;Redis 内存回收机制&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;volatile-lru -&amp;gt; remove the key with an expire set using an LRU algorithm&lt;/li&gt;
  &lt;li&gt;allkeys-lru -&amp;gt; remove any key accordingly to the LRU algorithm&lt;/li&gt;
  &lt;li&gt;volatile-random -&amp;gt; remove a random key with an expire set&lt;/li&gt;
  &lt;li&gt;allkeys-random -&amp;gt; remove a random key, any key&lt;/li&gt;
  &lt;li&gt;volatile-ttl -&amp;gt; remove the key with the nearest expire time (minor TTL)&lt;/li&gt;
  &lt;li&gt;noeviction -&amp;gt; don’t expire at all, just return an error on write operations&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;什么时候设置过期时间&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;正常 key-value 存储，使用 expire expireat 等，在更新缓存之后更新&lt;/li&gt;
  &lt;li&gt;对于hash/set/list/sortedset 数据结构，要先更新过期时间，再添加/修改数据 &lt;strong&gt;为什么?&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以hash结构举例，如果 key_test 中现在已经有&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;a&lt;/th&gt;
      &lt;th&gt;b&lt;/th&gt;
      &lt;th&gt;c&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;那么此时如果要新增一个域为 d 值为 4 的数据&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
$key = 'key_test';
$redis = new Redis();
$redis-&amp;gt;hset($key, 'd', 4);
$redis-&amp;gt;expire($key, 60);

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;一般情况下都会这么写，但是如果在执行 hset 之前，key_test 恰好到期了，那么缓存中就只剩下&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;d&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这个时候缓存就成脏数据了，所以代码需要这么写&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
$key = 'key_test';
$redis = new Redis();
$rs = $redis-&amp;gt;expire($key, 60);
if(!$rs) {
    //当TTL更新失败时表明缓存已经丢失了，需要做回源更新
    $redis-&amp;gt;hmset('key_test', array('a' =&amp;gt; 1, 'b'=&amp;gt; 2, 'c' =&amp;gt; 3));
}
$redis-&amp;gt;hset('key_test', 'd', 4);

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;ttl&quot;&gt;TTL&lt;/h3&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/*
 * 限制用户第一次访问站点之后，60s内不能访问
 */

$is_lock = isLock($uid);
lock($uid, $expire);

if($is_lock) {
    return false;
}

function isLock($uid) {
    $key = 'pre-' . $uid;
    $redis = new Redis();
    return $redis-&amp;gt;exists($key);
}

function lock($uid, $expire) {
    $key = 'pre-' . $uid;
    $redis = new Redis();
    $redis-&amp;gt;setex($key, $expire, 1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个逻辑会造成用户第一次可以访问，如果再 60 s 内一直在刷页面的话，会导致 key 的 TTL 一直在更新，将永远不能再次访问成功&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;[server]$ &lt;/span&gt;redis-cli 
&lt;span class=&quot;gp&quot;&gt;127.0.0.1:6379&amp;gt; &lt;/span&gt;setex test_key 60 1
OK
&lt;span class=&quot;gp&quot;&gt;127.0.0.1:6379&amp;gt; &lt;/span&gt;ttl test_key
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;integer&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 52
&lt;span class=&quot;gp&quot;&gt;127.0.0.1:6379&amp;gt; &lt;/span&gt;setex test_key 60 1
OK
&lt;span class=&quot;gp&quot;&gt;127.0.0.1:6379&amp;gt; &lt;/span&gt;ttl test_key
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;integer&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 59
&lt;span class=&quot;gp&quot;&gt;127.0.0.1:6379&amp;gt; &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;注意，每次设置 setex 和 expire ，key 的TTL也会重新开始计算&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-7&quot;&gt;更新缓存的策略&lt;/h1&gt;

&lt;p&gt;先看几种不同的更新策略（假设数据库和缓存更新必成功）&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;先更新缓存再更新数据库&lt;/li&gt;
  &lt;li&gt;先淘汰缓存再更新数据库&lt;/li&gt;
  &lt;li&gt;先更新数据库再更新缓存&lt;/li&gt;
  &lt;li&gt;先更新数据库再淘汰缓存&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;分析&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;先更新缓存再更新数据库&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;会有脏数据。&lt;/p&gt;

      &lt;p&gt;比如并发两个请求，A 请求要将数据修改为 aa ， B 请求要将数据修改成 bb 。&lt;/p&gt;

      &lt;p&gt;当 A 请求先修改了 cache 为 aa ，等待数据库连接并且发送改库命令。此时 B 请求也来了将 cache 修改为 bb ，然后也执行了数据库操作，由于抢先发送了改库命令，此时数据库数据为 bb ，然后 A 请求修改数据库数据成功为 aa 。那么此时，cache 内数据为 bb，但是数据库内数据为aa&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;先淘汰缓存再更新数据库&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;会有脏数据。&lt;/p&gt;

      &lt;p&gt;比如此时数据库内数据为 cc ，并发来了两个请求，A 请求读取数据 ， B 请求要将数据修改成 bb 。&lt;/p&gt;

      &lt;p&gt;请求 B 需要修改数据，先将缓存删除了，此时请求 A 读取缓存，穿透缓存后读取到数据数据为 cc ，然后将缓存设置为 cc 。然而 B 请求却将数据库内数据修改为了 bb 。以后的数据读取到的都是老数据。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;先更新数据库再淘汰缓存&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;同样是查询和修改的请求并发。没有先删除 cache ，而是先更新数据库中的数据。在数据库的更新过程中，cache 依然有效，所以并发的查询操作都可以获取到 cache 的数据。但是当数据库更新操作成功后，cache马上失效了，后续的查询操作会穿透缓存把数据从数据库中拉出来，再更新入缓存中。&lt;/p&gt;

      &lt;p&gt;但是这个策略理论上也可能会存在有脏数据的可能。&lt;/p&gt;

      &lt;p&gt;比如还是数据库内数据为 cc ，并发来了两个请求，A 请求读取数据 ， B 请求要将数据修改成 bb 。&lt;/p&gt;

      &lt;p&gt;请求 A 查询时缓存恰好过期了，然后去数据库读取到数据 cc ，在设置 cc 入缓存之前，请求 B 要完成数据库的更新和缓存的删除两步操作，等待 B 请求操作完毕之后，A 将 cc 写入缓存。
这种情况需要 1. 查询时没有缓存。2. 在改库操作之前查询到数据库。3. 在改库操作和删除缓存之后更新缓存。 但是改库操作执行时间一般要比查询时间长，同时改库还会表锁或行锁，查询请求必须在改库前进入并且改库后修改缓存，才能造成脏数据，概率很小。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;先更新数据库再更新缓存&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;基本策略同&lt;em&gt;先更新数据库再淘汰缓存&lt;/em&gt;，但是避免了删除缓存后的穿透现象，适用于超高并发的情景&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>xubin gao</name></author><summary type="html">为了使程序执行速度更快，所以现有业务中大量使用了缓存机制，这里主要介绍下平时业务中用到的缓存的应用及缓存更新的策略。由于缓存涉及到的场景太多了，所以本次仅介绍书写代码时最最常用的基础知识。</summary></entry></feed>
